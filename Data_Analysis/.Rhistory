## and it's inverse matrix as well. This funtion provides the get and set functions to
## access the matrix and inverse matrix
makeCacheMatrix<- function(y=matrix())
{
inverse<- NULL
set <- function(x) {
y <<- x
inverse<<- NULL
}
get <- function() { y }
#setinv <- function() { inverse<<-solve(y) }
setinv <- function(solve) { inverse<<-solve }
getinv <- function() { inverse}
list(set = set, get = get,
setinv = setinv  ,
getinv = getinv )
}
## cacheSolve allows to return the cached or normal inverse matrix
cacheSolve<-function(y,...)
{
inv<-NULL
inv<-y$getinverse()
if(!is.null(inv))
{
message("Getting cached Inverse")
return(inv)
}
# set the inverse and then fetch it
y$setinverse()
inv<-y$getinverse()
message("Getting Inverse")
inv
}
cacheSolve(makeCacheMatrix(matrix(runif(9),3,3)))
## Using Lexical Scoping of [R] to provide caching
## makeCacheMatrix function allows to cache a matrix which is passed as a formal argument to this function
## and it's inverse matrix as well. This funtion provides the get and set functions to
## access the matrix and inverse matrix
makeCacheMatrix<- function(y=matrix())
{
inverse<- NULL
set <- function(x) {
y <<- x
inverse<<- NULL
}
get <- function() { y }
setinv <- function() { inverse<<-solve(y) }
getinv <- function() { inverse}
list(setmatrix = set, getmatrix = get,
setinverse = setinv  ,
getinverse = getinv )
}
## cacheSolve allows to return the cached or normal inverse matrix
cacheSolve<-function(y,...)
{
inv<-NULL
inv<-y$getinverse()
if(!is.null(inv))
{
message("Getting cached Inverse")
return(inv)
}
# set the inverse and then fetch it
y$setinverse()
inv<-y$getinverse()
message("Getting Inverse")
inv
}
makeCacheMatrix(x)
cacheSolve(makeCacheMatrix(matrix(runif(9),3,3)))
cacheSolve(makeCacheMatrix(matrix(runif(4),2,2)))
+set.seed(123)
+r = rnorm(10000)
+mat = matrix(r, nrow=100, ncol=100)
inverse(mat)
?inverse
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
#inverse from the cache
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
# Define function to set the inverse. This is only used by getinverse() when
# there is no cached inverse
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cacheSolve <- function(x) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
return(inv)
}
## Sample run:
## > x = rbind(c(1, -1/4), c(-1/4, 1))
## > m = makeCacheMatrix(x)
## > m$get()
##       [,1]  [,2]
## [1,]  1.00 -0.25
## [2,] -0.25  1.00
## No cache in the first run
## > cacheSolve(m)
##           [,1]      [,2]
## [1,] 1.0666667 0.2666667
## [2,] 0.2666667 1.0666667
## Retrieving from the cache in the second run
## > cacheSolve(m)
## getting cached data.
##           [,1]      [,2]
## [1,] 1.0666667 0.2666667
## [2,] 0.2666667 1.0666667
##
inverse = function(matrix){
m = makeCacheMatrix(matrix)
start.time = Sys.time()
cacheSolve(m)
duration = Sys.time() - start.time
print(duration)
start.time = Sys.time()
cacheSolve(m)
duration = Sys.time() - start.time
print(duration)
}
set.seed(123)
r = rnorm(10000)
mat = matrix(r, nrow=100, ncol=100)
inverse(mat)
in
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
#inverse from the cache
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
# Define function to set the inverse. This is only used by getinverse() when
# there is no cached inverse
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cacheSolve <- function(x) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
return(inv)
}
## Sample run:
## > x = rbind(c(1, -1/4), c(-1/4, 1))
## > m = makeCacheMatrix(x)
## > m$get()
##       [,1]  [,2]
## [1,]  1.00 -0.25
## [2,] -0.25  1.00
## No cache in the first run
## > cacheSolve(m)
##           [,1]      [,2]
## [1,] 1.0666667 0.2666667
## [2,] 0.2666667 1.0666667
## Retrieving from the cache in the second run
## > cacheSolve(m)
## getting cached data.
##           [,1]      [,2]
## [1,] 1.0666667 0.2666667
## [2,] 0.2666667 1.0666667
##
inverse = function(matrix){
m = makeCacheMatrix(matrix)
start.time = Sys.time()
cacheSolve(m)
duration = Sys.time() - start.time
print(duration)
start.time = Sys.time()
cacheSolve(m)
duration = Sys.time() - start.time
print(duration)
}
set.seed(123)
r = rnorm(10000)
mat = matrix(r, nrow=100, ncol=100)
inverse(mat)
cacheSolve(makeCacheMatrix(matrix(runif(4),2,2)))
## This two functions allows to caching the inverse of a matrix
## by utilising the lexical scoping of R
## - written by Yinan Zhang
## This function define the list containing various function:
## a) set the value of the matrix
## b) get the value of the matrix
## c) set the value of the inverse of the matrix
## d) get the value of the inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setInverse <- function(solve) {m <<- solve}
getInverse <- function() {m}
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function calculates the inverse of the matrix.
## The if condition checks firstly whether the inverse
## of the matrix has been defined already. And if:
## a) the inverse has beeen defined by getInverse, then
##    the same value will be returned
## b) m is NULL, this function will calcualte the inverse
##    of the given matrix and return the m.
cacheSolve <- function(x, ...) {
m <- x$getInverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setInverse(m)
m
}
cacheSolve(makeCacheMatrix(matrix(runif(4),2,2)))
## This two functions allows to caching the inverse of a matrix
## by utilising the lexical scoping of R
## - written by Yinan Zhang
## This function define the list containing various function:
## a) set the value of the matrix
## b) get the value of the matrix
## c) set the value of the inverse of the matrix
## d) get the value of the inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setInverse <- function(solve) {m <<- solve}
getInverse <- function() {m}
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function calculates the inverse of the matrix.
## The if condition checks firstly whether the inverse
## of the matrix has been defined already. And if:
## a) the inverse has beeen defined by getInverse, then
##    the same value will be returned
## b) m is NULL, this function will calcualte the inverse
##    of the given matrix and return the m.
cacheSolve <- function(x, ...) {
m <- x$getInverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setInverse(m)
m
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
cacheSolve(my_matrix)
my_matrix$getInverse()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## Matrix inversion is usually a costly computation
## and there may be some benefit to caching the inverse of a matrix
## rather than compute it repeatedly (there are also alternatives to matrix inversion that we will not discuss here).
## Your assignment is to write a pair of functions that cache the inverse of a matrix.
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
# Initially set to NULL
# Changes when the user sets the value
inv <- NULL
# set function
# Sets the matrix itself but not the inverse
set <- function(y) {
x <<- y    # Set the value
m <<- NULL # Clear the cache
}
# Define function to get the value of the matrix
get <- function() x
# Define function to set the inverse. This is only used by getinverse() when
# there is no cached inverse
setInverse <- function(inverse) inv <<- inverse
# Define function to get the inverse
getInverse <- function() inv
# Return a list with the above four functions
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Write a short comment describing this function
# This function computes the inverse of the special "matrix" returned by
# makeCacheMatrix above. If the inverse has already been calculated
# (and the matrix has not changed), then the cachesolve retrieves the
# inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# Get the current state of the inverse and see if it
# has been computed yet
inv <- x$getInverse()
if(!is.null(inv)){
message("Getting cached matrix")
return(inv)
}
# The cache was empty. We need to calculate it, cache it, and then return it.
data <- x$get()
# Find the inverse
inv <- solve(data, ...)
# Cache this result in the object
x$setInverse(inv)
# Return this new result
inv
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
myMatrix <- matrix(round(runif(9, min = 1, max = 10)), 3, 3)
myMatrix
m$get()
m = makeCacheMatrix((myMatrix))
m
m$get()
cacheSolve(m)
cacheSolve(m
cacheSolve(m)
cacheSolve(m)
?cat
cat(1:4)
c(1:4)
x <- cat(1:4)
y - c(1:4)
y <- c(1:4)
x
y
cat(15, "depoisted. Your balance is", 5, "\n\n")
cat(15, "depoisted. Your balance is", 5)
cat(15, fill = FALSE, lables = NULL, append = FALSE)
cat(15, 123, fill = FALSE, lables = NULL, append = FALSE)
cat(15, 123, fill = TRUE, lables = NULL, append = FALSE)
cat(15, 123, fill = TRUE, lables = NULL, append = TRUE)
open.account <- function(total) {
list(
deposit = function(amount) {
if(amount <= 0)
stop("Deposits must be positive!\n")
total <<- total + amount
cat(amount, "deposited.  Your balance is", total, "\n\n")
},
withdraw = function(amount) {
if(amount > total)
stop("You don't have that much money!\n")
total <<- total - amount
cat(amount, "withdrawn.  Your balance is", total, "\n\n")
},
balance = function() {
cat("Your balance is", total, "\n\n")
}
)
}
open.account <- function(total) {
list(
deposit = function(amount) {
if(amount <= 0)
stop("Deposits must be positive!\n")
total <<- total + amount
cat(amount, "deposited.  Your balance is", total, "\n\n")
},
withdraw = function(amount) {
if(amount > total)
stop("You don't have that much money!\n")
total <<- total - amount
cat(amount, "withdrawn.  Your balance is", total, "\n\n")
},
balance = function() {
cat("Your balance is", total, "\n\n")
}
)
}
open.account(15)
open.account(15)$deposit(1)
open.account(-1)$deposit(1)
open.account0$deposit(1)
open.account(0)$deposit(1)
open.account(0)$deposit(0)
open.account(0)$deposit(-1)
yinan <- open.account(9999)
yinan
deposit
yinan[deposit]
yinan[1]
yinan["deposit"]
yinan["deposit(10)"]
yinan[deposit(10)]
yinan <- open.account(9999)
yinan$deposit(10)
yinan
yinan(1)
yinan("1")
yinan("deposit")
yinan[1]
yinan["deposit"]
class(yinan["deposit"])
length(yinan["deposit"])
yinan
length(yinan)
length(yinan$deposit)
yinan$deposit(10)
yinan["deposit(10)"]
yinan[1]
yinan <- open.account(10)
yinan$balace()
yinan$balance()
yinan$deposit(10)
yinan$withdraw(10)
str(yinan)
x <- rnorm(100,2,4)
summary(x)
str(x)
x
f <- gl(40,10)
f
summary(f)
str(f)
airquality
summary(airquality)
split(airquality,airquality$Temp)
x <. rnorm(10)
x <- rnorm(10)
x
x <- rnorm(10)
x
x <- rbinom(100,1,0.5)
x
by.self
?by.self
Rprof(yinan)
Rprof(lm)
?Rprof
set.seed(1)
rpois(5, 2)
?ppois
x <- rep(0:1, each = 5)
x
install.packages("devtools")
library(devtools)
library(devtools)
install_github("StatsWithR/statsr")
library(readr)
growthrates_rcp2p6_co2_for_sustag_1SD_national_all_crops <- read_csv("N:/agpo/work1/SUSTAg/capri/capri3/dat/scen/agmip/LPJmL_ISIMIP_for_SUSTAg/csv/growthrates_rcp2p6_co2_for_sustag_1SD_national_all_crops.csv")
View(growthrates_rcp2p6_co2_for_sustag_1SD_national_all_crops)
library(xlsx)
install.packages(xlsx)
install-install.packages(xlsReadWrite)
install.packages(xlsReadWrite)
install.packages("xlsx")
libary(xlsx)
library(xlsx)
library("xlsx)
library("xlsx")
install.packages("xlsx")
library("xlsx")
library("xlsx")
install.packages("xlsx")
View(growthrates_rcp2p6_co2_for_sustag_1SD_national_all_crops)
library("xlsx")
install.packages("xlsx", dependencies = TRUE)
library("xlsx")
write.xlsx(x, file = "myworkbook.xlsx",
sheetName = "USA-ARRESTS", append = FALSE)
install.packages("openxlsx")
library("openxlsx")
library(readr)
growthrates_rcp2p6_noco2_for_sustag_1SD_national_all_crops <- read_csv("N:/agpo/work1/SUSTAg/capri/capri3/dat/scen/agmip/LPJmL_ISIMIP_for_SUSTAg/csv/growthrates_rcp2p6_noco2_for_sustag_1SD_national_all_crops.csv")
View(growthrates_rcp2p6_noco2_for_sustag_1SD_national_all_crops)
write.xlsx(growthrates_rcp2p6_noco2_for_sustag_1SD_national_all_crops, "rcp2p6_noco2.xlsx")
write.xlsx(growthrates_rcp2p6_noco2_for_sustag_1SD_national_all_crops, 'rcp2p6_noco2.xlsx')
